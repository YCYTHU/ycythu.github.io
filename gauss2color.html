<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Gaussian Curve Drawer</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #f9f9f9;
      font-family: sans-serif;
    }
  
    #canvas-container {
      width: 100%;
      max-width: 1000px;
      margin: auto;
      position: relative;
    }
  
    canvas {
      width: 100%;
      height: auto;
      display: block;
      background: white;
      border: 1px solid #ccc;
      touch-action: none;
    }
  </style>
</head>
<body>
<div id="canvas-container">
  <canvas id="canvas"></canvas>
</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const DPR = window.devicePixelRatio || 1;

let WIDTH = canvas.clientWidth;
let HEIGHT = 500;

const xAxis = [300, 800];

function setCanvasSize() {
  WIDTH = canvas.clientWidth;
  canvas.width = WIDTH * DPR;
  canvas.height = HEIGHT * DPR;
  ctx.setTransform(1, 0, 0, 1, 0, 0); // Reset transform
  ctx.scale(DPR, DPR);
}
setCanvasSize();
window.addEventListener('resize', () => {
  setCanvasSize();
  draw();
});

const gaussians = [];
let dragging = null;
let selected = null;

const peakRadius = 6;
const widthHandleLength = 6;

function canvasToAxisX(x) {
  return xAxis[0] + (x / WIDTH) * (xAxis[1] - xAxis[0]);
}
function axisToCanvasX(x) {
  return WIDTH * (x - xAxis[0]) / (xAxis[1] - xAxis[0]);
}

function drawAxis() {
  const axisY = HEIGHT - 20;
  const tickStep = 50;

  ctx.beginPath();
  ctx.moveTo(0, axisY);
  ctx.lineTo(WIDTH, axisY);
  ctx.strokeStyle = '#333';
  ctx.lineWidth = 1;
  ctx.stroke();

  ctx.fillStyle = '#333';
  ctx.font = '12px sans-serif';
  ctx.textAlign = 'center';

  for (let x = xAxis[0]; x <= xAxis[1]; x += tickStep) {
    let xPos = axisToCanvasX(x);
    ctx.beginPath();
    ctx.moveTo(xPos, axisY);
    ctx.lineTo(xPos, axisY + 5);
    ctx.stroke();
    ctx.fillText(x, xPos, axisY + 18);
  }
}

function draw() {
  ctx.clearRect(0, 0, canvas.width / DPR, canvas.height / DPR);

  // Draw Gaussian curve
  ctx.beginPath();
  ctx.moveTo(0, HEIGHT);
  for (let x = 0; x <= WIDTH; x++) {
    const axisX = canvasToAxisX(x);
    const y = HEIGHT - totalGaussianY(axisX);
    ctx.lineTo(x, y);
  }
  ctx.strokeStyle = 'steelblue';
  ctx.lineWidth = 2;
  ctx.stroke();

  for (let g of gaussians) {
    const isSelected = selected === g;
    const cx = axisToCanvasX(g.mu);
    const cy = HEIGHT - g.A;

    ctx.beginPath();
    ctx.arc(cx, cy, peakRadius, 0, 2 * Math.PI);
    ctx.fillStyle = isSelected ? 'darkred' : 'crimson';
    ctx.fill();

    const wx = axisToCanvasX(g.mu + g.sigma * widthHandleLength);
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.lineTo(wx, cy);
    ctx.strokeStyle = 'gray';
    ctx.stroke();

    ctx.beginPath();
    ctx.arc(wx, cy, peakRadius, 0, 2 * Math.PI);
    ctx.fillStyle = 'orange';
    ctx.fill();
  }

  drawAxis();
  exportNormalizedData();
}

function totalGaussianY(axisX) {
  return gaussians.reduce((sum, g) => {
    return sum + g.A * Math.exp(-((axisX - g.mu) ** 2) / (2 * g.sigma ** 2));
  }, 0);
}

function getEventPos(e) {
  const rect = canvas.getBoundingClientRect();
  const client = e.touches ? e.touches[0] : e;
  return [client.clientX - rect.left, client.clientY - rect.top];
}

function handleStart(e) {
  e.preventDefault();
  const [x, y] = getEventPos(e);
  const cx = x, cy = y;
  selected = null;

  for (let g of gaussians) {
    const gx = axisToCanvasX(g.mu);
    const gy = HEIGHT - g.A;
    if (distance(cx, cy, gx, gy) < peakRadius + 2) {
      dragging = { type: 'peak', g };
      selected = g;
      draw();
      return;
    }
    const wx = axisToCanvasX(g.mu + g.sigma * widthHandleLength);
    if (distance(cx, cy, wx, gy) < peakRadius + 2) {
      dragging = { type: 'sigma', g };
      selected = g;
      draw();
      return;
    }
  }

  const mu = canvasToAxisX(cx);
  const A = HEIGHT - cy;
  const newG = { mu, A, sigma: 0.02 * (xAxis[1] - xAxis[0]) };
  gaussians.push(newG);
  selected = newG;
  draw();
}

function handleMove(e) {
  if (!dragging) return;
  e.preventDefault();
  const [x, y] = getEventPos(e);
  const g = dragging.g;

  if (dragging.type === 'peak') {
    g.mu = canvasToAxisX(x);
    g.A = HEIGHT - y;
  } else if (dragging.type === 'sigma') {
    const muCanvas = axisToCanvasX(g.mu);
    const dx = x - muCanvas;
    const dAxis = dx * (xAxis[1] - xAxis[0]) / WIDTH;
    g.sigma = dAxis / widthHandleLength;
    if (g.sigma < 1) g.sigma = 1;
  }
  draw();
}

function handleEnd() {
  dragging = null;
}

function distance(x1, y1, x2, y2) {
  return Math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2);
}

canvas.addEventListener('mousedown', handleStart);
canvas.addEventListener('mousemove', handleMove);
canvas.addEventListener('mouseup', handleEnd);
canvas.addEventListener('mouseleave', handleEnd);
canvas.addEventListener('touchstart', handleStart, { passive: false });
canvas.addEventListener('touchmove', handleMove, { passive: false });
canvas.addEventListener('touchend', handleEnd);

document.addEventListener('keydown', (e) => {
  if (e.key === 'Delete' && selected) {
    const idx = gaussians.indexOf(selected);
    if (idx !== -1) {
      gaussians.splice(idx, 1);
      selected = null;
      draw();
    }
  }
});

function exportNormalizedData() {
  const data = [];
  const steps = 500;
  const [minX, maxX] = xAxis;

  let maxY = 0;
  for (let i = 0; i <= steps; i++) {
    const x = minX + (i / steps) * (maxX - minX);
    const y = totalGaussianY(x);
    data.push({ x, y });
    if (y > maxY) maxY = y;
  }

  const normalized = data.map(p => ({ x: p.x, y: maxY > 0 ? p.y / maxY : 0 }));
  console.log('Normalized Data:', normalized);
}

draw();
</script>
